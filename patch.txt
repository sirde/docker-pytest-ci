--- tag_nxp.py	2018-03-14 09:52:27.541741500 +0100
+++ tag_nxp_modified.py	2018-03-14 10:01:47.871898500 +0100
@@ -688,6 +688,215 @@
         return s
 
 
+class NTAGI2CPLUS(tt2.Type2Tag):
+    """Base class for the NTAGI2CPLUS family (NT3H2211/NT3H2111). The
+    methods and attributes documented here are supported for all
+    NT3H2X products.
+
+    All NT3H2X products support a simple password protection scheme
+    that can be configured to restrict write as well as read access to
+    memory starting from a selected page address. A factory programmed
+    ECC signature allows to verify the tag unique identifier.
+
+    """
+
+    class NDEF(tt2.Type2Tag.NDEF):
+        def _read_capability_data(self, tag_memory):
+            if super(NTAGI2CPLUS.NDEF, self)._read_capability_data(tag_memory):
+                if self.tag.is_authenticated:
+                    if not self._readable and tag_memory[15] >> 4 == 8:
+                        self._readable = True
+                    if not self._writeable and tag_memory[15] & 0xF == 8:
+                        self._writeable = bool(tag_memory[10:12] == b"\0\0")
+                return True
+            return False
+
+    @property
+    def signature(self):
+        """The 32-byte ECC tag signature programmed at chip production. The
+        signature is provided as a string and can only be read.
+
+        The signature attribute is always loaded from the tag when it
+        is accessed, i.e. it is not cached. If communication with the
+        tag fails for some reason the signature attribute is set to a
+        32-byte string of all zeros.
+
+        """
+        log.debug("read tag signature")
+        try:
+            return bytes(self.transceive(b"\x3C\x00"))
+        except tt2.Type2TagCommandError:
+            return 32 * b"\0"
+
+    def protect(self, password=None, read_protect=False, protect_from=0):
+        """Set password protection or permanent lock bits.
+
+        If the *password* argument is None, all memory pages will be
+        protected by setting the relevant lock bits (note that lock
+        bits can not be reset). If valid NDEF management data is
+        found, protect() also sets the NDEF write flag to read-only.
+
+        All Tags of the NTAG21x family can alternatively be protected
+        by password. If a *password* argument is provided, the
+        protect() method writes the first 4 byte of the *password*
+        string into the Tag's password (PWD) memory bytes and the
+        following 2 byte of the *password* string into the password
+        acknowledge (PACK) memory bytes. Factory default values are
+        used if the *password* argument is an empty string. Lock bits
+        are not set for password protection.
+
+        The *read_protect* and *protect_from* arguments are only
+        evaluated if *password* is not None. If *read_protect* is
+        True, the memory protection bit (PROT) is set to require
+        password verification also for reading of protected memory
+        pages. The value of *protect_from* determines the first
+        password protected memory page (one page is 4 byte) with the
+        exception that the smallest set value is page 3 even if
+        *protect_from* is smaller.
+
+        """
+        args = (password, read_protect, protect_from)
+        return super(NTAGI2CPLUS, self).protect(*args)
+
+    def _protect(self, password, read_protect, protect_from):
+        if password is None:
+            return self._protect_with_lockbits()
+        else:
+            args = (password, read_protect, protect_from)
+            return self._protect_with_password(*args)
+
+    def _protect_with_lockbits(self):
+        try:
+            ndef_cc = self.read(3)[0:4]
+            if ndef_cc[0] == 0xE1 and ndef_cc[1] >> 4 == 1:
+                ndef_cc[3] = 0x0F
+                self.write(3, ndef_cc)
+            self.write(2, b"\x00\x00\xFF\xFF")
+            if self._cfgpage > 16:
+                self.write(self._cfgpage - 1, b"\xFF\xFF\xFF\x00")
+            cfgdata = self.read(self._cfgpage)
+            if cfgdata[4] & 0x40 == 0:
+                cfgdata[4] |= 0x40  # set CFGLCK bit
+                self.write(self._cfgpage + 1, cfgdata[4:8])
+            return True
+        except tt2.Type2TagCommandError:
+            return False
+
+    def _protect_with_password(self, password, read_protect, protect_from):
+        if password and len(password) < 6:
+            raise ValueError("password must be at least 6 bytes")
+
+        key = password[0:6] if password != b"" else b"\xFF\xFF\xFF\xFF\0\0"
+        log.debug("protect with key " + hexlify(key))
+
+        # read CFG0, CFG1, PWD and PACK
+        cfg = self.read(self._cfgpage)
+
+        # set password and acknowledge
+        cfg[8:14] = key
+
+        # start protection from page
+        cfg[3] = max(3, min(protect_from, 255))
+
+        # set read protection bit
+        cfg[4] = cfg[4] | 0x80 if read_protect else cfg[4] & 0x7F
+
+        # write configuration to tag
+        for i in range(4):
+            self.write(self._cfgpage + i, cfg[i * 4:(i + 1) * 4])
+
+        # Set NDEF read/write permissions if protection starts at page
+        # 3 and the tag is formatted for NDEF. We set the read/write
+        # permission flags to 8, thus indicating proprietary access.
+        if protect_from <= 3:
+            ndef_cc = self.read(3)[0:4]
+            if ndef_cc[0] == 0xE1 and ndef_cc[1] & 0xF0 == 0x10:
+                ndef_cc[3] |= (0x88 if read_protect else 0x08)
+                self.write(3, ndef_cc)
+
+        # Reactivate the tag to have the key effective and
+        # authenticate with the same key
+        self._target = self.clf.sense(self.target)
+        return self.authenticate(key) if self.target else False
+
+    def authenticate(self, password):
+        """Authenticate with password to access protected memory.
+
+        An NTAG21x implements a simple password protection scheme. The
+        reader proofs possession of a share secret by sending a 4-byte
+        password and the tag proofs possession of a shared secret by
+        returning a 2-byte password acknowledge. Because password and
+        password acknowledge are transmitted in plain text special
+        considerations should be given to under which conditions
+        authentication is performed. If, for example, an attacker is
+        able to mount a relay attack both secret values are easily
+        lost.
+
+        The *password* argument must be a string of length zero or at
+        least 6 byte characters. If the *password* length is zero,
+        authentication is performed with factory default values. If
+        the *password* contains at least 6 bytes, the first 4 byte are
+        send to the tag as the password secret and the following 2
+        byte are compared against the password acknowledge that is
+        received from the tag.
+
+        The authentication result is True if the password was
+        confirmed and False if not.
+
+        """
+        return super(NTAGI2CPLUS, self).authenticate(password)
+
+    def _authenticate(self, password):
+        if password and len(password) != 4:
+            raise ValueError("password must be 4 bytes")
+
+        key = password[0:4] if password != b"" else b"\xFF\xFF\xFF\xFF"
+        log.debug("authenticate with key " + hexlify(key))
+
+        try:
+            rsp = self.transceive(b"\x1B" + key[0:4])
+            print('key', hexlify(key))
+            print('rsp:', rsp)
+            return True
+            # return rsp == key[4:6]
+        except tt2.Type2TagCommandError:
+            return False
+
+    # def _dump(self, stop, footer):
+    #     lines = super(NTAGI2CPLUS, self)._dump(stop)
+    #     for i in sorted(footer.keys()):
+    #         try:
+    #             data = self.read(i)[0:4]
+    #         except tt2.Type2TagCommandError:
+    #             data = [None, None, None, None]
+    #         lines.append(tt2.pagedump(i, data, footer[i]))
+    #     return lines
+
+    def _dump(self, stop):
+        s = super(NTAGI2CPLUS, self)._dump(stop)
+
+        data = self.read(stop)[0:4]
+        s.append(tt2.pagedump(stop, data, "LOCK2-LOCK4, CHK"))
+
+        # data = self.read(232)
+        # s.append("")
+        # s.append("Configuration registers:")
+        # s.append(tt2.pagedump(stop & 256 | 232, data[0:4],
+        #                       "NC, LD, SM, WDT0"))
+        # s.append(tt2.pagedump(stop & 256 | 233, data[4:8],
+        #                       "WDT1, CLK, LOCK, RFU"))
+        #
+        # self.sector_select(3)
+        # data = self.read(248)
+        # s.append("")
+        # s.append("Session registers:")
+        # s.append(tt2.pagedump(0x3F8, data[0:4], "NC, LD, SM, WDT0"))
+        # s.append(tt2.pagedump(0x3F9, data[4:8], "WDT1, CLK, NS, RFU"))
+
+        self.sector_select(0)
+        return s
+
+
 class NT3H1101(NTAGI2C):
     """NTAG I2C 1K.
 
@@ -711,6 +920,17 @@
     def dump(self):
         return super(NT3H1201, self)._dump(480)
 
+class NT3H2211(NTAGI2CPLUS):
+    """NTAG I2C PLUS 2K.
+
+    """
+    def __init__(self, clf, target):
+        super(NT3H2211, self).__init__(clf, target)
+        self._product = "NTAG I2C PLUS 2K (NT3H2211)"
+
+    def dump(self):
+        return super(NT3H2211, self)._dump(16)
+
 
 VERSION_MAP = {
     b"\x00\x04\x03\x01\x01\x00\x0B\x03": MF0UL11,
@@ -725,7 +945,7 @@
     b"\x00\x04\x04\x05\x02\x01\x13\x03": NT3H1101,
     b"\x00\x04\x04\x05\x02\x01\x15\x03": NT3H1201,
     # b"\x00\x04\x04\x05\x02\x02\x13\x03": NT3H2111,
-    # b"\x00\x04\x04\x05\x02\x02\x15\x03": NT3H2211,
+    b"\x00\x04\x04\x05\x02\x02\x15\x03": NT3H2211,
 }
 
 
@@ -763,4 +983,4 @@
         log.debug(repr(error))
         return
 
-    return MifareUltralight(clf, target)
\ No newline at end of file
+    return MifareUltralight(clf, target)
